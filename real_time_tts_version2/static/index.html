<!DOCTYPE html>
<html>
<head>
    <title>Real-time Sentence TTS</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 50px auto;
            padding: 20px;
            background: #f8f9fa;
        }
        
        textarea {
            width: 100%;
            height: 120px;
            font-size: 16px;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            resize: vertical;
            box-sizing: border-box;
        }
        
        .status {
            margin: 15px 0;
            padding: 10px;
            border-radius: 4px;
            font-size: 14px;
            text-align: center;
        }
        
        .status.connected { background: #d4edda; color: #155724; }
        .status.speaking { background: #fff3cd; color: #856404; }
        
        .controls {
            margin: 15px 0;
            text-align: center;
        }
        
        .controls button {
            padding: 8px 16px;
            margin: 0 5px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .controls button:hover { background: #0056b3; }
    </style>
</head>
<body>
    <h2>üéôÔ∏è Real-time TTS</h2>
    
    <textarea id="textBox" placeholder="Type and end sentences with periods (.) to hear them spoken immediately..."></textarea>
    
    <div id="status" class="status">Connecting...</div>
    
    <div class="controls">
        <button id="clearBtn">Clear</button>
        <button id="resetBtn">Reset</button>
    </div>

    <script>
        const socket = new WebSocket("ws://localhost:8000/ws/tts");
        const textBox = document.getElementById("textBox");
        const status = document.getElementById("status");
        const clearBtn = document.getElementById("clearBtn");
        const resetBtn = document.getElementById("resetBtn");
        
        let audioQueue = [];
        let isPlaying = false;
        let currentAudio = null;
        let lastSentText = "";

        // Send text immediately on any change
        textBox.addEventListener("input", (e) => {
            const text = e.target.value;
            
            // Check if a new sentence was completed
            if (hasNewSentence(text)) {
                socket.send(text);
                lastSentText = text;
            }
        });

        // Check if there's a new complete sentence
        function hasNewSentence(currentText) {
            // If text is shorter than before, always send (user might have deleted)
            if (currentText.length < lastSentText.length) {
                return true;
            }
            
            // Count sentences in current vs last text
            const currentSentences = (currentText.match(/[.!?]/g) || []).length;
            const lastSentences = (lastSentText.match(/[.!?]/g) || []).length;
            
            return currentSentences > lastSentences;
        }

        // Audio playback
        async function playNextAudio() {
            if (isPlaying || audioQueue.length === 0) return;

            isPlaying = true;
            const audioData = audioQueue.shift();
            
            try {
                status.textContent = "üó£Ô∏è Speaking...";
                status.className = "status speaking";

                const response = await fetch(audioData.audio_path);
                const blob = await response.blob();
                const audio = new Audio(URL.createObjectURL(blob));
                currentAudio = audio;

                audio.onended = () => {
                    isPlaying = false;
                    currentAudio = null;
                    setTimeout(() => playNextAudio(), 50);
                };

                audio.onerror = () => {
                    isPlaying = false;
                    currentAudio = null;
                    setTimeout(() => playNextAudio(), 50);
                };

                await audio.play();
                
            } catch (err) {
                isPlaying = false;
                currentAudio = null;
                setTimeout(() => playNextAudio(), 50);
            }
        }

        // WebSocket handlers
        socket.onmessage = async (event) => {
            const data = JSON.parse(event.data);
            if (data.audio_path && data.type === "sentence") {
                audioQueue.push(data);
                playNextAudio();
            }
        };

        socket.onopen = () => {
            status.textContent = "‚úÖ Connected";
            status.className = "status connected";
        };

        socket.onclose = () => {
            status.textContent = "‚ùå Disconnected";
            status.className = "status";
        };

        // Controls
        clearBtn.addEventListener("click", () => {
            textBox.value = "";
            lastSentText = "";
        });

        resetBtn.addEventListener("click", () => {
            audioQueue = [];
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }
            isPlaying = false;
            lastSentText = "";
            status.textContent = "‚úÖ Connected";
            status.className = "status connected";
        });

        // Update status when idle
        setInterval(() => {
            if (!isPlaying && audioQueue.length === 0 && socket.readyState === WebSocket.OPEN) {
                status.textContent = "‚úÖ Connected";
                status.className = "status connected";
            }
        }, 2000);
    </script>
</body>
</html>